あなたは CUDA と Python のコーディングスキルを持つ ChatGPT です。
あなたのタスクは、GPU の sin/cos 近似関数が FFT の精度と回転の安定性など実用にどのように影響するかを評価する 4 つの実験を行うためのコード（CUDA C/C++ と Python）を生成することです。
これらのプログラムは、CUDA がインストールされた NVIDIA RTX 5090 上で実行します。
最終的に可視化した誤差は記事にはって使用します。

https://zenn.dev/toropippi/articles/d8def1c994e0a9 これがそのgpuの誤差についての記事です
全ての実験で3条件を比較します。
比較対象はdoubleでやったのを正解値としてfloat精度の誤差なしsin cosを使用したfft vs 高速近似sin cosを使用したfftです。
誤差なしsin cosはdoubleで計算したのをキャストします。vramに埋め込んでおきテーブル参照します。

環境の前提

GPU は NVIDIA RTX 5090。CUDA の Compute Capability は 8.x 以上と仮定してよい。
CUDA ソースのコンパイルには nvcc を使用する。自前で radix-2 Cooley–Tukey FFT を実装する。
高精度の sin/cos については、CPU 側で double 精度でツイードル係数（twiddle factor）のテーブルを事前計算し、float にキャストして 定数メモリまたは グローバル配列にアップロードする。これにより SFU 近似誤差を排除する。
近似版では、ツイードル係数を GPU カーネル内で __sinf() / __cosf() によりオンザフライ計算する
結果および中間統計量は、Python スクリプトで読み取り・描画できるように バイナリまたは CSV に保存する。

実験 1 – FFT による多倍長整数乗算

桁数が異なる（例：1024, 8192 桁）ランダムな 10 進整数 A と B を生成する。畳み込み可能にするため、各1桁整数を base-k 配列（base 10 または 2 のべき乗）に変換する。

入力長の合計より大きい 次の 2 のべき乗サイズに対応する in-place FFT を実装する。3条件の CUDA 実装を作る

畳み込みは、両入力に対して順 FFT → 周波数領域で要素ごとの積 → 逆 FFT を行うことで実施する。

逆 FFT 後の float(またはdouble) 値をそのまま表示して人間が体感として誤差をみる。

本来整数に限りなく近くなるはずだが、誤差が蓄積し小数点以下の数字が.9128みたいになることが期待される。

3条件の誤差を測定
doubleの結果、または入力ABから、その配列要素にくるはずの正解整数値をもとめ、3条件の浮動小数点数がどのくらいの誤差を持つか比較する。
これはpythonで行うので、ひとまず浮動小数点数を劣化なくCSV に出力する


実験 2 – 単一 FFT の誤差解析

さまざまな入力信号を生成する：ランダム実ベクトル、純正弦波、正弦波の和。長さは 1024 や 65536 など。

CPU 側で double 精度 FFTを計算し、参照（リファレンス）とする。

GPU の 3 つの FFT 実装（3条件）を実行し、複素スペクトルをホストへ取得する。

各要素 k について、参照値との 絶対誤差および 相対誤差を計算する。

GPU 出力に対して逆 FFT も行い、再構成信号と元信号との差の L2 ノルムを計算する。

要素ごとの誤差、または集約統計（平均・最大）を CSV に書き出す。

Python スクリプトはこれらを読み、誤差ヒストグラムおよび「周波数インデックスに対する最大誤差」の折れ線グラフを描画する。


実験 3 – 回転行列の連続適用

単位行列 3×3 から開始する。Z 軸周りに小角度（例：1°）回転する回転行列を定義する。

GPU 上で、この回転行列を累積行列に対して多数回（例：360 回以上）掛け続ける。2 種類のカーネルを用意する：

高精度版：小角度の sin/cos は double 由来の float テーブルから読み込む。

近似版：sin/cos を __sinf/__cosf で計算する。

n 回ごと（例：64 回ごと）に現在の行列をバッファへ書き出し、後から有効回転角と直交性誤差（各列のノルムが 1 からどれだけズレるか、列同士の内積が 0 からどれだけズレるか）を評価できるようにする。

バッファをホストにコピーし、理論回転角（反復回数 × 角度）と、累積行列から推定した実際の角度（例：atan2）を比較し、角度誤差（度）を記録する。

反復回数に対する誤差を CSV に保存する。Python は、高精度／近似それぞれについて「角度誤差 vs 反復回数」「ノルム誤差 vs 反復回数」を折れ線グラフで描画する。

実験 4 – ランダム入力の平均誤差

長さ N のランダム実ベクトル（平均 0、分散 1 の白色雑音）を多数生成し、各ベクトルについて 3条件 の 方式で FFT を計算する。

各 FFT 結果について複素スペクトルの L2 ノルムを計算する（Parseval により入力ノルム × √N に等しいはず）。各 GPU のノルムと参照 CPU ノルムの 相対誤差を求める。

十分なモンテカルロ試行（例：1000）を行い、高精度／近似それぞれの相対誤差の平均と標準偏差を算出できるようにする。

trial index, high-precision relative error, fast relative error を含む CSV を出力する。

Python はこのファイルを読み、要約統計を計算し、高精度／近似それぞれの相対誤差分布のヒストグラムを描画する。

Python 解析スクリプト

4 実験の出力ファイルを受け取り、pandas DataFrame として読み込み、matplotlib（seaborn 不使用、色の明示指定もしない）で以下を作図する Python スクリプトを作成する：

実験 1：整数長に対する誤り率（誤り桁率％）の棒グラフ（高精度／近似）。誤り桁数と最大桁誤差の要約表も作る。

実験 2：FFT ビンごとの絶対誤差ヒストグラム、周波数ごとの最大誤差の折れ線。さらに入力タイプごとの再構成 MSE を比較するプロット。

実験 3：反復回数に対する角度誤差とノルム誤差の折れ線（高精度／近似）。

実験 4：相対誤差分布のヒストグラムと、平均・ばらつきを示す箱ひげ図（高精度／近似）。

各図は figures ディレクトリに PNG として保存し、結果要約の DataFrame も CSV として出力する。

出力要件

上記実験を実装した CUDA/C++ の完全なソースコードを提示する。機能分離を明確にし、各ステップを説明するコメントを含める。

Python 解析スクリプトも別ファイルとして完全な形で提示する。

一般的な CUDA 開発環境で、修正なしでコンパイル・実行可能であることを保証する。

プログラム末尾で、プロット前にざっと確認できるように 要約統計を標準出力またはログ出力する。